---
title: "[SQLD] 2과목 SQL 기본 및 활용 - 2"
toc: true
toc_sticky: true
toc_label: "Getting Started"
description: null
summary: null
tags: SQLD
published: true
categories:
  - SQLD
---

# 2과목 SQL 기본 및 활용 - 2
## 1. 서브 쿼리
### 서브쿼리란
- 하나의 SQL문 안에 포함되어 있는 또 다른 SQL 문을 말함
- 반드시 괄호로 묶어야함
- ex) SELECT문 안에 SELECT
- ex) INSERT, UPDATE, DELETE안에 SELECT문

### 서브쿼리 사용 가능한 곳
- SELECT, FROM, WHERE, HAVING, ORDER BY절 에서 사용가능
- 기타 DML(INSERT, DELETE, UPDATE)절
- GROUP BY절 사용 불가

### 서브 쿼리 종류
#### 동작하는 방식에 따른 서브쿼리
- UN-CORRELATED(비연관) 서브쿼리
  - 서브 쿼리가 메인 쿼리 컬럼을 가지고 있지 않은 형태의 서브 쿼리
  - 메인 쿼리에 서브 쿼리가 실행된 결과 값을 제공하기 위한 목적으로 사용
- CORRELATED(연관) 쿼리
  - 서브 쿼리가 메인 쿼리 컬럼을 가지고 있는 형태의 서브 쿼리
  - 일반적으로 메인 쿼리가 먼저 수행된 후에 서브쿼리에서 조건이 맞는지 확인하고자 할 때 사용

#### 위치에 따라 서브쿼리
- 스칼라 서브쿼리
  - SELECT절에 사용하는 서브쿼리
  - 서브쿼리에 결과를 하나의 컬럼처럼 사용하기 위해 주로 사용
- 인라인 뷰 
  - FROM절에 사용하는 서브쿼리
  - 서브쿼리 결과를 테이블처럼 사용하기 위해 주로 사용
- WHERE절 서브쿼리
  - 가장 일반적인 서브 쿼리
  - 비교 상수 자리에 값을 전달하기 위한 목적으로 주로 사용(상수항 대체)
  - 리턴 데이터의 형테에 따라 단일행 서브쿼리, 다중행 서브쿼리, 다중컬럼 서브쿼리, 상호연관 서브쿼리로 구분
```sql
SELECT *
FROM 테이블명 or 뷰명
WHERE 조건연산자 (SELECT * FROM 테이블명 or 뷰명 WHERE 조건);
```

### WHERE절 서브쿼리 종류
#### 단일행 서브쿼리
- 서브쿼리 결과가 1행의 행이 리턴되는 형태 (값이 1개 리턴)
- 
```sql
-- 급여의 평균보다 높게 받는 직원 이름과 급여 출력
SELECT EMPNO, NAME, SAL
FROM EMP
WHERE SAL > (SELECT AVG(SAL) FROM EMP);
```

#### 다중행 서브쿼리
- 서브쿼리 결과가 여러 행이 리턴되는 형태 (값이 여러 개 리턴)
- " >, <, =, <>, >=, <= " 연산자 사용 불가
- 다중행 서브쿼리 연산자 비사용

##### 다중행 서브 쿼리 종류
- IN(a,b) : a혹은 b랑 같은 값을 출력
- " > ALL(2000, 3000) " : 3000 보다 큰 최대 값
  - 2000보다 크고 3000보다 큰 값 중에서 최대 값을 반환

- " < ALL(2000, 3000) " : 2000 보다 작은 최소 값
  - 2000보다 작고 3000보다 작은 값 중에서 최소 값을 반환

- " < ANY(2000, 3000) " : 3000보다 작은 값중 최대 값
  - 2000보다 작아도 되고 3000보다 작아도 되는 값 중에서 최대 값을 반환
- " > ANY(2000, 3000) " : 2000보다 큰 값중 최소 값
  - 2000보다 작아도 되고 3000보다 작아도 된다.q

#### 다중 컬럼 서브쿼리
- 서브쿼리 결과가 여러 컬럼이 리턴
- 메인쿼리와의 비교 컬럼이 2개 이상일 때
- 대소 비교 전달 불가 (두 컬럼의 값을 묶에 비교할 수 없음)
```sql
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) IN
(SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO); 
```
- FROM절 : EMP 테이블 데이터를 읽어온다.
- WHERE절
  - 서브쿼리 : DEPTNO를 그룹화 하고 급여의 최대값을 읽어온다
  - 메인쿼리 : DEPTNO, SAL에 서브쿼리 결과가 있는지 확인한다.
- SELECT절 : 조건에 맞는 EMPNO, ENAME, SAL, DEPTNO를 출력한다.

#### 상호연관 서브쿼리
- 메인쿼리와 서브쿼리의 비교를 수행하는 형태
- 비교할 집단이나 조건은 서브쿼리에 명시 
  - 메인쿼리절에는 서브쿼리 컬럼이 정의되지 않았기 때문에 에러 발생
```sql
-- 부서 별 평균 급여보다 많이 받는 직원을 찾는다.
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP E1
WHERE SAL > (SELECT AVG(SAL) 
              FROM EMP E2 
              WHERE E1.DEPTNO = E2.DEPTNO GROUP BYQ DEPTNO);
```

### 인라인 뷰
- 쿼리 안의 뷰의 형태로 테이블처럼 조회할 테이터를 정의
- FROM절에 테이블 처럼 사용하기 때문에 어디서든 사용가능하다.
```sql
-- 부서 별 최대급여를 뷰를 만들어 EMP 테이블과 비교해서 최대 급여자를 찾는다.
SELECT E.EMPNO, E.ENAME, E.SAL, I.MAX_SAL
FROM EMP E, (SELECT DEPTNO, MAX(SAL) "MAX_SAL" 
              FROM EMP 
              GROUP BY DEPTNO) I
WHERE E.DEPTNOP = I.DEPTNO
AND E.SAL = MAX_SAL;

-- 부서 별 평균 급여보다 많은 급여를 받는 직원 찾기
SELECT E1.EMPNO, E1.ENAME, E1.SAL, I.AVG_SAL
FROM EMP E1, (SELECT DEPTNO, AVG(SAL) AVG_SAL
              FROM EMP 
              WHERE E1.DEPTNO = I.DEPTNO 
              GROUP BY DEPTNO) I
WHERE E.DEPTNO = I.DEPTNO
AND SAL > I.AVG_SAL;
```

### 스칼라 서브쿼리
- SELECT절에 사용하는 쿼리로, 하나의 컬럼처럼 표현하기 위해 사용
- 각 행마다 스칼라 서브쿼리 결과가 하나여야 한다(단일행 서브쿼리 형태)

```sql
SELECT E.EMPNO, E.ENAME, (SELECT D.DNAME 
                          FROM DEPT D 
                          WHERE D.DEPTNO = E.DEPTNO) DANME
FROM EMP E
```

### 서브쿼리 주의사항
- 특별한 경우(TOP-N 분석 등) 을 제외하고 서브 쿼리절에 ORDER BY절 사용 불가
- 단일 행 서브쿼리와 다중 행 서브쿼리에 따라 연산자의 선택이 중요

## 2. 집합 연산자
### 집합 연산자
- SELECT문의 결과를 하나의 집합으로 간주, 집합의 합집합, 교집합, 차집합 여산
- SELECT문과 SELECT문 사이에 집합 연산자 정의
- 두 집합의 컬럼이 동일하게 구성되어야 한다.
  - 컬럼명은 달라도 데이터 타입과 순서는 일치해야 한다.
- 전체 집합의 데이터타입과 컬럼명은 첫 번째 집합에 의해 결정된다.

### 합집합
- 두 집합의 총 합(전체) 출력
- UNION 과 UNION ALL 사용 가능

#### UNION
- 중복된 데이터는 한번만 출력
- 중복된 데이터를 제거하기 위해 내부적으로 정렬 수행
- 중복된 데이터가 없을 경우는 UNION 사용 대신 UNION ALL 사용
  - UNION을 사용하면 불필요한 정렬이 발생할 수 있음.

#### UNION
- 중복된 데이터도 전체 출력

### 교집합
- 두 집합 사이에 INTERSECT
- 두 집합의 교집합 출력

### 차집합
- 두 집합 사이에 MINUS 전달
- 두 집합의 차집합 출력
- 먼저 쓴 쿼리 출력 값 - 나중에 쓴 쿼리 출력 값
- 순서가 중요함

## 3. 그룹 함수
- 숫자 함수 중 여러 값을 전달하여 하나의 요약 값을 출력하는 다중행 함수
- 수학/통계 함수들
- GROUP BY절에 의해 그룹별 연산 결과를 리턴
- 반드시 한 컬럼만 전달
- NULL은 무시하고 여산
### 그룹 함수 종류
#### COUNT()
- 행의 수를 세는 함수
- 대상 컬럼은 * 또는 하나의 컬럼만 전달 가능

#### SUM()
- 총 합 출력
- 숫자만 입력 가능

#### AVG()
- 평균을 계산
- NULL을 제외한 계산이기 때문에 NVL등 치환하여 계산

#### MIN, MAX()
- 최대 값, 최소 값을 전달
- 날짜, 문자, 숫자 모두 가능

#### VARIANCE/STDDEV
- 평균과 표준 편차
- 표준 편차는 평균 값의 루트 값

### GROUP BY FUNCTION
- GROUP BY절에 사용하는 함수
- 여러 GROUP BY 결과를 동시에 출력(합집합)하는 기능
- 그룹핑 할 그룹을 정의(전체 소계 등)

#### GROUPING SETS(A, B, C, ...)
- A별, B별,... 그룹 연산 결과 출력
- 나열 순서 중요하지 않다.
- 기본 출력에 전체 총계는 출력되지 않는다.
- NULL 혹은 () 사용하여 전체 총 합 출력 가능
```sql
-- DEPTNO 별 급여 총합, 직무 별 급여 총합을 모두 나타낸다.
-- GROUPING SETS 예제
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB);
-- 전체 합계를 구할 때 () 빈 괄호
-- GROUP BY GROUPING SETS(DEPTNO, JOB, ()); 
```
- UNION ALL로 출력 가능하지만 NULL값을 넣어야하고 문장이 길어진다.
- GROUP BY GROUPING SETS(DEPTNO, JOB, ()) 처럼 GROUPING SETS에 () 빈 괄호를 넣으면 전체 합계가 출려된다.

#### ROLLIP(A, B)
- A별, (A, B)별, 전체 그룹 연산 결과 출력
- 나열 대상의 순서가 중요하다
- 기본적으로 전체 총 합계가 출 력
```sql
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOP);
```
- DEPTNO와 JOP이 같을 경우 급여 합계출력
- DEPTNO별 그룹 연산을 출력한다

| DEPTNO | JOB     | SUM(SAL) | 구분                     |
|--------|---------|----------|--------------------------|
| 10     | CLERK   | 1300     | DEPTNO, JOB의 그룹연산   |
| 10     | MANAGER | 2450     |                          |
| 10     |         | 8750     | DEPTNO별 그룹연산        |
| 20     | CLERK   | 1900     | DEPTNO, JOB의 그룹연산   |
| 20     | MANAGER | 6000     |                          |
| 20     |         | 10870    | DEPTNO별 그룹연산        |

- DEPTNO와 JOB별 그룹 연산이 출력되고
- DEPTNO에 그룹 연산도 출력된다.

#### CUBE(A, B)
- A별, B별, (A, B)별, 전체 그룹 연산 결과 출력
- 그룹으로 묶을 대상의 나열 순서 중요하지 않음
- 기본적으로 전체 총 계가 출력됨.

```sql
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOP);
```
| DEPTNO | JOB       | SUM(SAL) |
|--------|-----------|----------|
| 10     | CLERK     | 1300     |
| 10     | MANAGER   | 2450     |
| 20     | CLERK     | 1900     |
| 20     | MANAGER   | 2975     |
| 30     | CLERK     | 950      |
| 30     | MANAGER   | 2850     |
| 30     |           | 10000    |
| 20     |           | 7000     |
| 10     |           | 6000     |
|        |           | 41325    |
|        | CLERK     | 20000    |
|        | MANAGER   | 16000    |


## 4. 윈도우 함수
### WINDOW FUNCTION
- 서로 다른 행의 비교나 연산을 위해 만든 함수
- GROUP BY를 쓰지 않고 그룹 연산을 사능
- LAG, LEAD, SUM, AVG, MIN, MAX, COUNT, RANK
```sql
-- 문법
SELECT 윈도우함수([대상]) 
OVER ([PARTITION BY 컬럼]
      [ORDER BY 컬럼]
      [ROWS또는RANGE BETWEEN A AND B]);
```
`PARTITION BY절 -> ORDER BY절 -> ROWS 또는 RANGE BETWEEN A AND B 순으로 전달 순서 중요`

#### PARTITION BY절
- 출력할 총 데이터 수 변화 없이 그룹연산 수행할 GROUP BY 컬럼

#### ORDER BY절
- RANK의 경우 필수(정렬 컬럼 및 정렬 순서에 따라 순위 변화)
- SUM, AVG, MIN, MAX, COUNT 등은 누적 값 출력 시 사용 

#### ROWS 또는 RANGE BETWEEN A AND B
- 연산 범위 설정
- ORDER BY절 피수

#### WINDOW 함수가 필요한 이유
```sql
-- 그룹 함수의 오류
SELECT EMPNO, ENAME, SAL, DEPTNO, SUM(SAL)
FROM EMP;
```
전체를 출력하는 컬럼과 그룹함수 결과는 함께 출력할 수 없다.

### 그룹 함수의 형태
- SUM, COUNT, AVG, MIN, MAX 등
- OVER절을 사용하여 WINDOW 함수로 사용 가능
- 반드시 연산할 대상을  그룹 함수의 입력 값으로 입력

```sql
--. 윈도우 함수 사용 
-- SUM 예시
SELECT EMPNO, ENAME, SAL, DEPTNO, 
        SUM(SAL) OVER() TOTAL
FROM EMP;
```

| EMPNO | ENAME   | SAL  | DEPTNO | TOTAL |
|-------|---------|------|--------|-------|
| 7369  | SMITH   | 800  | 20     | 29025 |
| 7499  | ALLEN   | 1600 | 30     | 29025 |
| 7521  | WARD    | 1250 | 30     | 29025 |

```sql
-- 윈도우 함수 사용 AVG 예시
SELECT EMPNO, ENAME, SAL, DEPTNO, 
        AVG(SAL) OVER(PARTITION BY DEPTNO) AVG_SAL
                      ORDER BY DEPTNO
FROM EMP;
```

| EMPNO | ENAME   | SAL  | DEPTNO | AVG_SAL |
|-------|---------|------|--------|---------|
| 7839  | KING    | 5000 | 10     | 5000    |
| 7782  | CLARK   | 5000 | 10     | 5000    |
| 7369  | SMITH   | 2000 | 20     | 3000    |
| 7902  | FORD    | 4000 | 20     | 3000    |
| 7698  | BLAKE   | 10000| 30     | 6000    |
| 7900  | JAMES   | 2000 | 30     | 6000    |

### ROWS, RANGE 차이
#### ROWS 
- 값이 같더라도 각 행씩 연산
- ROWS를 사용할 때 범위를 반드시 입력해야 한다.
#### RANGE - DEFUALT
- 값이 같은 경우 하나의 RANGE로 묶어서 동시 연산

### BETWEEN A AND B
- 시작점 정의
  - CURRENT ROW : 현재 행부터
  - UNBOUNDED PRECEDING : 처음부터 (DEFAULT)
  - N PRECEDING : N 이전  부터

- 마지막 시점 정의
  - CURRENT ROW : 현재 행부터  (DEFAULT)
  - UNBOUNDED FOLLOWING : 마지막 까지
  - N PRECEDING : N 이전  부터

```sql
-- RANGE 기본 값이므로 SAL이 동일한 값은 묶어서 연산
SELECT E.* SUM(SAL) OVER(ORDER BY SAL) SAL_SUM
FROM EMP E
```
| EMPNO | ENAME   | SAL  | DEPTNO | SAL_SUM |
|-------|---------|------|--------|---------|
| 7369  | SMITH   | 800  | 20     | 800     |
| 7521  | WARD    | 1000 | 30     | 1800    |
| 7934  | MILLER  | 1200 | 10     | 4200    |
| 7844  | TURNER  | 1200 | 30     | 4200    |
| 7499  | ALLEN   | 1500 | 30     | 5700    |

```sql
-- ROWS는 값이 같아도 각각 연산
SELECT E.* 
  SUM(SAL) OVER(ORDER BY SAL 
  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) SAL_SUM
FROM EMP E
```

| EMPNO | ENAME   | SAL  | DEPTNO | SAL_SUM |
|-------|---------|------|--------|---------|
| 7369  | SMITH   | 800  | 20     | 800     |
| 7521  | WARD    | 1000 | 30     | 1800    |
| 7934  | MILLER  | 1200 | 10     | 3000    |
| 7844  | TURNER  | 1200 | 30     | 4200    |
| 7499  | ALLEN   | 1500 | 30     | 5700    |


### 순위 관련 함수
#### RANK(순위)
##### RANK WITHIN GROUP
- 특정 값에 대한 순위 확인
- 윈도우 함수가 아닌 일반 함수
```sql
-- 급여가 3000일 때 전체 급여 순위를 특정
SELECT RANK(3000) WITHIN GROUP(ORDER BY SAL DESC) RANK_VALUE
FROM EMP;
```
##### RANK(), OVER()
- 전체 중/ 특정 그룹 중 값의 순위 확인
- ORDER BY절 필수
- 순위를 구할 대상을 ORDER BY절에 명시 
  - `여러 개 나열 가능`
- 그룹 내 순위 구할 시 PARTITION BY절 사용
- 동일 순위이 경우 `1등, 2등, 2등, 4등`

```sql
-- 직원에 급여의 전체 순위 (큰 순서대로)
SELECT ENAME, DEPTNO, SAL,
        RANK() OVER(ORDER BY SAL DESC) RANK_VALUE
FROM EMP;
```

| ENAME  | DEPTNO | SAL  | RANK_VALUE |
|--------|--------|------|------------|
| BLAKE  | 30     | 2850 | 1          |
| SCOTT  | 20     | 3000 | 2          |
| FORD   | 20     | 3000 | 2          |
| JONES  | 20     | 2975 | 4          |
| KING   | 10     | 5000 | 5          |

```sql
-- 부서 별 급여 순위
SELECT ENAME, DEPTNO, SAL,
        RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) RANK
FROM EMP;
```

| ENAME  | DEPTNO | SAL  | RANK |
|--------|--------|------|------|
| KING   | 10     | 5000 | 1    |
| CLARK  | 10     | 2450 | 2    |
| MILLER | 10     | 1300 | 3    |
| SCOTT  | 20     | 3000 | 1    |
| FORD   | 20     | 3000 | 1    |
| JONES  | 20     | 2975 | 3    |
| ALLEN  | 30     | 1600 | 1    |
| BLAKE  | 30     | 2850 | 2    |
| JAMES  | 30     | 950  | 3    |

#### DENSE_RANK
- 누적 순위
- 동일 순위일 때 동일한 순위를 부여 후 다음 순위가 바로 이어지는 순위 방식
- `1등, 1등, 1등, 2등, 3등`

#### ROW_NUMBER
- 연속된 행 번호
- 동일한 순위를 인정하지 않고 단순히 순서대로 나열한대로 값을 리턴

```sql
-- RANK(), DENSE_RANK(), ROW_NUMBER() 비교
SELECT ENAME, DEPTNO, SAL,
        RANK() OVER(ORDER BY SAL DESC) RANK1,
        DENSE_RANK() OVER(ORDER BY SAL DESC) RANK2,
        ROW_NUMBER() OVER(ORDER BY SAL DESC) RANK3
FROM EMP;
```

| ENAME  | DEPTNO | SAL  | RANK1 | RANK2 | RANK3 |
|--------|--------|------|-------|-------|-------|
| BLAKE  | 30     | 2850 | 1     | 1     | 1     |
| SCOTT  | 20     | 3000 | 2     | 2     | 2     |
| FORD   | 20     | 3000 | 2     | 2     | 3     |
| JONES  | 20     | 2975 | 4     | 3     | 4     |

### LAG, LEAD
- 행 순서대로 각각 이전 값(LAG), 이후 값(LEAD) 가져오기
- ORDER BY절 필수
```sql
-- 문법
```