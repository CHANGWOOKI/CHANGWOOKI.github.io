---
title: "[JAVA] 실전 정리 - 05(final, 상속 관계)"
toc: true
toc_sticky: true
toc_label: "Getting Started"
description: null
summary: null
tags: JAVA
published: true
categories:
  - JAVA
---

```java
제일 다시 듣고 싶던 상속 관계를 들었다.
다시 들으니까 이해가 쑥쑥되고 주의사항이 더 잘들어온다.
더 열심히 듣고 정리해야겠다...
힘내자! 창욱
```
### 8) final(상수)
- final 키워드는 이름 그대로 끝! 이라는 뜻 `매우 유용한 제약이다.`
- 변수에 final 키워드가 붙으면 더는 값을 변경할 수 없다.

#### final 변수와 상수

#### 지역변수
- final을 지역 변수에 설정할 경우 최초 한번만 할당할 수 있다. 이후 값을 변경하려면 컴파일 오류가 발생한다.
- final을 지역 변수 선언시 바로 초기화 한 경우 이미 값이 할당되었기 떄문에 값을 할당할 수 없다.
- 매겝변수에 final이 붙으면 메서드 내부에서 매게변수의 값을 변경할 수 없다. 따라서 메서드 호출 시점에 사용된 값이 끝까지 사용된다.

#### 맴버 변수(필드)
- 초기화 하지 않은 final 맴버 변수를 인스턴스화 하면 각 인스턴스마다 값을 1번 씩 할당할 수 있다.
- 초기화된 final 맴버 변수는 인스턴스화 해도 모두 같은 값을 가진다. 이는 명백한 메모리 낭비이다. 이럴 경우 __static final__ 변수를 사용한다.

#### 상수(Constant)  static final
- 상수는 항상 변하지 않고, 같은 값을 갖는 수
- 자바에서는 단 하나만 존재하는 변하지 않는 고정된 값
- __static final__ 키워드를 사용한다.
- 변수와 상수를 구분하기 위해 전부 대문자를 사용하며 _(언더바)로 띄어쓰기 구분한다(관례)
- 필드를 직접 접근해서 사용한다.
- 고정된 값을 사용하는게 목적이다. 한번 할당된 값을 변경할 수 없기 떄문에 필드에 직접 접근해 데이터가 변하는 문제가 발생하지 않는다.

#### final 참조값
```java
final Data data = new Data()
data.value = 10;
data.value = 20;
```
- 참조형 변수에 final이 붙으면 참조 대상을 변경하지 못하는 것이다.
- 변수 이외에 다른 곳에 영향을 주는 것이 아니다.
- data가 참조하는 값은 변경 불가하지만 data.value의 값은 변경 가능하다.

#### 클래스와 메서드에 사용되는 final

클래스에 final
- 상속이 끝났다는 의미
- final로 선언된 클래스는 확장될 수 없다. `다른 클래스가 final로 선언된 클래스를 상속 받을 수 없다.`
- ex) public final class Book{...}

메서드에 final
- 오버라이딩를 더 이상 할수 없다.
- final로 선언된 메서드는 오버라이드 될 수 없다. 상속 받은 하위 클래스에서 이 메서드를 재정의 할 수 없다.


### 9) 상속

#### 상속 관계
- 객체 지향 프로그래밍의 핵심 요소
- 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해준다.
- 이름 그대로 속성과 기능을 그대로 물려받는 것이다.
- 상속을 사용하려면 __extends__ 키워드를 사용

##### 용어 정리
- __부모 클래스 (슈퍼 클래스)__ : 상속을 통해서 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
- __자식 클래스 (서브 클래스)__ :  부모 클래스로부터 필드와 메서드를 상속 받는 클래스

#### 상속 구조
- 부모 클래스의 기능을 자식 클래스에서 물려받는다.
- 부모 클래스는 자식 클래스에 접근할 수 없다.

##### 단일 상속
- 자바는 다중 상속을 지원하지 않는다.
- 부모 클래스를 하나만 선택할 수 있다.
- 부모 클래스가 다른 부모 클래스를 가질수 있다.

##### 상속의 메모리 구조
- 자식 클래스를 인스턴스화 하면 부모 클래스도 포함해서 인스턴스 생성한다.
- 참조값은 하나지만 그안에는 두가지의 클래스 정보가 공존한다.
- 상속 관계를 사용하면 부모 클래스도 함께 포함해서 생성된다.
- 시각적으로 하나의 인스턴스를 생성하는 것 같지만, 내부에서는 부모, 자식 클래스 모두 생성되고 공간도 구분한다.

##### 상속 호출
- 상속 관계 인스턴스를 생성하면 부모와 자식이 하나의 참조값으로 생기지만 따로 구분되어 있다.
- 객체를 호출할 때, 대상 타입을 정한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
- 현재 타입에서 기능을 찾지 못하면 상위 부모 클래스에서 찾아 실행한다. `찾지 못하면 컴파일 오류`

#### 상속과 메서드 오버라이딩
- 부모 클래스에서 상속 받은 기능을 재정의 하는 것을 오버라이딩이라고 한다.
- 메서드 윗줄에 @Override를 붙인다. (optional이지만 꼭 씀) `@는 애노테이션이라 한다. 프로그램이 읽을 수 있는 특별한 주석이라 생각하면 된다.`

#### 오버로딩(Overloading)과 오버라이딩(Overriding)
- __메서드 오버로딩__ : 메서드 이름이 같고 매게변수(파라미터)가 다른 메서드를 여러개 정의하는 것을 오버로딩

- __메서드 오버라이딩__ : 하위 클래스에서 상위 클래스의 메서드를 `재정의`하는 과정을 의미한다. `상속 관계에서 사용`

#### 메서드 오버라이딩 조건
- __메서드 이름__ : 메서드 이름이 같아야 한다.
- __메서드 파라미터__ : 파라미터 타입, 순서, 개수가 같아야한다.
- __반환 타입__ : 반환 타입이 같아야 한다.(`반환 타입이 하위 클래스 타입일 수 있다.`)
- __접근 제어자__ : 오버라이딩 메서드의 접근 제어자는 상위 클래스보다 더 제한적이어서는 안된다.
- __예외__ : 상위 클래스보다 더 많은 예외를 throws로 선언할 수 없다.
- __static__ : static은 참조값을 할당하는게 아닌 클래스를 바로 불러오기 때문에 불가능하다.
- __final__ : final은 키워드는 할당된 값 또는 메서드를 변경할 수 없기 때문
- __private__ : 부모 클래스 메서드의 접근 제어자가 private면 같은 클래스만 접근 가능하기 때문에 하위 클래스에서 보이지 않는다.
- __생성자__ : 생성자는 오버라이딩 될 수 없다.

#### 상속과 접근 제어
- __private__ : 모든 외부 호출은 막는다.`같은 클래스만 사용`
- __default__ : 같은 패키지안에서 호출은 허용
- __protected__ : 같은 패키지 안에서 허용, `상속 관계`의 호출은 패키지가 달라고 허용
- __public__ : 모든 외부 호출을 허용한다.

#### 접근 제어와 메모리 구조
- 본인 타입에서 먼저 찾고 없으면 부모 타입에서 찾는다.
- 인스턴스 내부에서는 자식과 부모가 구분되기 떄문에 자식 클래스에서 부모 클래스를 호출하는 것은 외부에서 호출한 것과 같다.

#### super-부모참조
- 부모와 자식 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없다.
- 이때 `super`키워드를 사용하면 참조할 수 있다.

#### super-생성자
- 상속 관계 인스턴스를 생성하면 메모리 내부에서 자식과 부모 클래스가 각각 만들어진다. 따라서 각각 생성자도 모두 호출되어야 한다.
- 상속 관계를 사용하면 `자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출`해야 한다. 단 `기본 생성자(super())일 경우 생략` 가능  `(규칙)`
- 자식 클래스에서 호출해도 초기화는 최상위 부모 클래스부터 이루어진다 `자식 생성자에서 super() 부모 생성자를 먼저 호출하기 떄문이다`

##### 예외
- `this`를 제일 먼저 써도된다. 단 부모 생성자는 받드시 한번은 호출해야 한다.
- `부모 클래스의 생성자가 기본 생성자(파라미터가 없는)` 경우에는 super를 생략할 수 있다.

































































































































































